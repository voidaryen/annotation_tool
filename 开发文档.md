# 正畸“症状-方案”逻辑关系标注工具 - 开发文档

## 1. 项目概述

### 1.1. 目标
开发一个轻量级的、基于浏览器的标注工具，用于建立正畸领域中“问题（症状/检查发现）”与“诊疗动作”之间的因果逻辑关系。该工具旨在将正畸专家的核心诊断逻辑数据化，同时通过大语言模型（LLM）自动化处理繁琐的文本拆分与标准化工作，让专家能专注于核心的逻辑判断。

### 1.2. 核心功能
1.  **数据解析与展示**：自动解析特定格式的病历文本，将“问题”和“方案”清晰地分列展示。
2.  **方案智能化拆分与标准化**：利用LLM将复杂的诊疗方案文本拆解为一系列原子化、标准化的“诊疗动作”，并维护一个可复用的“诊疗动作库”。
3.  **交互式逻辑链接**：提供一个直观的点击式界面，让用户能够轻松地在“问题”和“诊疗动作”之间建立、查看和取消逻辑链接。
4.  **数据持久化与迭代**：将标注结果以JSON格式保存，并能在用户保存时自动更新“诊疗动作库”，实现知识的持续沉淀和复用。

### 1.3. 技术选型
为了实现“在浏览器中即可打开使用”并结合“本地Python环境”的需求，我们采用**前后端分离**的B/S（Browser/Server）架构。

*   **前端 (Client)**：`HTML` + `CSS` + `JavaScript`。
    *   **职责**：负责所有用户界面的渲染和交互逻辑。无需任何框架，使用原生技术即可，保证最大的轻便性和兼容性。
    *   **运行环境**：用户的网页浏览器。
*   **后端 (Server)**：`Python` + `Flask` (或 `FastAPI`)。
    *   **职责**：作为本地服务器，处理文件读写、与LLM的交互、数据处理与标准化等“重”任务。
    *   **运行环境**：用户本地的Python环境。

这种架构的优势在于，它将复杂的计算和数据管理放在强大的Python后端，而将轻量、直观的用户交互放在普适的浏览器前端，完美契合您的需求。

## 2. 系统架构

```
+-------------------------------------------------+
|               用户浏览器 (Client)                 |
|                                                 |
|   +-------------------------------------------+   |
|   |                  index.html               |   |
|   |  +----------+       +-------------------+ |   |
|   |  | style.css|------>|   UI & 交互逻辑   | |   |
|   |  +----------+       +-------------------+ |   |
|   |  +----------+                 ^           |   |
|   |  | script.js|<----------------+           |   |
|   |  +----------+                 |           |   |
|   +-------------------------------|-----------+   |
|                   ^               |               |
|          (HTTP请求: API Calls)    |               |
|                   v               |               |
+-------------------|---------------------------------+
                    |
+-------------------|---------------------------------+
|       本地Python服务器 (Backend) - Flask          |
|                                                 |
|   +-------------------------------------------+   |
|   |                   app.py                  |   |
|   | +---------------------------------------+ |   |
|   | |             API Endpoints             | |   |
|   | |  - /api/patient/<id>  (获取数据)      | |   |
|   | |  - /api/save/<id>     (保存标注)      | |   |
|   | |  - /api/standardize   (调用LLM)       | |   |
|   | +---------------------------------------+ |   |
|   | +---------------------------------------+ |   |
|   | |             业务逻辑                  | |   |
|   | |  - 病历文件解析                      | |   |
|   | |  - 诊疗动作库管理 (读/写)            | |   |
|   | |  - LLM Prompt工程与调用             | |   |
|   | +---------------------------------------+ |   |
|   +-------------------------------------------+   |
|       ^         |          ^         |          |
|       | (读/写) |          | (读/写) |          |
+-------v---------v----------v---------v----------+
        |         |          |         |
+-------+--+  +---+------+  +--------+--+  +-------------+
| patient_ |  | annotation |  | action_   |  |   LLM API   |
| data.txt |  |  _data.json  |  | library.json |  | (e.g. OpenAI) |
+----------+  +------------+  +-----------+  +-------------+
```

## 3. 目录结构

建议采用以下目录结构来组织项目文件：

```
ortho-annotator/
|
├── app.py                   # Python后端主程序 (Flask)
|
├── templates/
|   └── index.html           # 前端主页面
|
├── static/
|   ├── css/
|   |   └── style.css        # CSS样式文件
|   └── js/
|       └── script.js        # JavaScript逻辑文件
|
├── data/
|   ├── patients/            # 存放原始病历数据
|   |   └── 00001.txt        # 示例病历文件
|   |   └── 00002.txt
|   |
|   ├── annotations/         # 存放标注结果
|   |   └── 00001.json       # 示例标注结果
|   |
|   └── action_library.json  # 全局诊疗动作库
|
└── requirements.txt         # Python依赖库
└── README.md                # 项目说明与使用指南
```

## 4. 后端实现 (Python/Flask)

`app.py` 是后端的核心。它将提供几个API接口供前端调用。

### 4.1. 主要依赖
```
# requirements.txt
flask
openai # 或者其他LLM库
```

### 4.2. API Endpoints

**1. `GET /`**
*   **功能**: 返回主页面 `index.html`。
*   **实现**: `return render_template('index.html')`

**2. `GET /api/patients`**
*   **功能**: 获取所有患者ID列表，用于前端的“上一例/下一例”导航。
*   **实现**: 扫描 `data/patients/` 目录，返回所有文件名（不含扩展名）的列表。

**3. `GET /api/patient/<patient_id>`**
*   **功能**: 获取指定患者的全部数据，包括原始问题和已标注的链接。
*   **实现**:
    *   读取 `data/patients/<patient_id>.txt` 文件。
    *   **解析病历**: 将文本按行和`<sep>`分割符解析成结构化的JSON。为每个“问题”条目生成一个唯一的ID（例如 `problem-0`, `problem-1`）。
    *   **处理诊疗方案 (核心功能)**:
        a.  从解析结果中提取 `TreatmentPlan` 字符串。
        b.  **步骤一：初步拆分**。将方案描述（如 `1. xxx 2. yyy`）按数字、换行等符号拆分成一个初步的动作列表。
        c.  **步骤二：调用LLM进行标准化**。将这个初步列表连同 `action_library.json` 的内容一起发送给LLM，要求其对新动作进行标准化和去重，并返回一个干净的、标准化的动作列表。
        d.  为每个最终的诊疗动作生成一个唯一的ID（例如 `action-0`, `action-1`）。
    *   **加载现有标注**: 检查 `data/annotations/<patient_id>.json` 是否存在。如果存在，则加载它。
    *   **返回数据**: 将解析出的问题列表、处理后的诊疗动作列表、以及已有的标注链接，组合成一个大的JSON对象返回给前端。

**4. `POST /api/save/<patient_id>`**
*   **功能**: 保存前端提交的标注结果。
*   **实现**:
    *   接收前端发来的JSON数据，其内容是“诊疗动作ID”到“问题ID列表”的映射。
    *   将其保存到 `data/annotations/<patient_id>.json`。
    *   **更新诊疗动作库**: 从接收到的数据中提取所有新的或修改过的诊疗动作文本，与 `data/action_library.json` 中的现有动作进行合并、去重，然后写回文件。这一步确保了知识的持续积累。

### 4.3. LLM集成 (关键部分)

这是实现“诊疗动作标准化”的核心。

*   **Prompt设计**: Prompt是关键。它需要清晰地告诉LLM要做什么。

    **示例Prompt**:
    ```text
    你是一个专业的正畸医生和数据工程师。你的任务是将一个复杂的诊疗方案，拆分成一系列独立的、标准化的、可复用的诊疗动作。

    这里是一个已有的“标准诊疗动作库”，请尽量复用这些已有的表述：
    [
        "排齐牙列",
        "解除拥挤",
        "纠正中线",
        "调整磨牙关系",
        "内收前牙",
        "压低前牙",
        "片切",
        "拔除智齿",
        "正畸保持"
    ]

    现在，请处理以下新的诊疗方案步骤：
    [
        "1. 上下唇倾排齐，解除拥挤及扭转",
        "2. 后牙锁合先利用矫治器纠正，若无法完成则利用交互牵引纠正",
        "3. 维持磨牙关系",
        "4. 智齿酌情",
        "5. 正畸保持"
    ]

    请遵循以下规则：
    1. 将每个步骤分解为最基本的、独立的动作。例如，“上下唇倾排齐，解除拥挤及扭转”应分解为“排齐上颌牙列”、“排齐下颌牙列”、“解除拥挤”、“纠正扭转牙”。
    2. 标准化表述。例如，“智齿酌情”应标准化为“拔除智齿（酌情）”。“维持磨牙关系”已经很标准，直接使用。
    3. 如果新动作与库中已有动作意思相同，请使用库中的表述。
    4. 忽略不属于诊疗“动作”的描述，如风险告知（“...牙根吸收...可能性”）。
    5. 以JSON列表格式返回最终结果，不要包含任何其他解释。

    你的输出应该是这样的JSON格式：["动作1", "动作2", ...]
    ```

*   **调用**: 在后端代码中，构造这个Prompt，然后通过API（如OpenAI的API）发送给LLM，并解析返回的JSON结果。

## 5. 前端实现 (HTML/CSS/JavaScript)

### 5.1. HTML结构 (`index.html`)

页面主体分为三部分：控制区、问题区、方案区。

```html
<body>
    <div class="container">
        <header class="controls">
            <h1 id="patient-info">正畸“症状-方案”逻辑关系标注</h1>
            <div class="navigation">
                <button id="prev-patient">上一例</button>
                <select id="patient-selector"></select> <!-- 可选：快速选择病人 -->
                <button id="next-patient">下一例</button>
            </div>
            <button id="save-btn">保存标注</button>
        </header>

        <main class="workspace">
            <div class="panel" id="problems-panel">
                <h2>问题（症状、检查发现）</h2>
                <div id="problems-container" class="chip-container">
                    <!-- JS会在这里动态生成问题词块 -->
                </div>
            </div>

            <div class="panel" id="solutions-panel">
                <h2>诊疗动作（双击修改）</h2>
                <div id="solutions-container" class="chip-container">
                    <!-- JS会在这里动态生成诊疗动作词块 -->
                </div>
            </div>
        </main>
    </div>

    <script src="/static/js/script.js"></script>
</body>
```

### 5.2. CSS样式 (`style.css`)

*   使用Flexbox或Grid进行布局，实现左右两栏。
*   定义`.chip`（词块）的样式：背景色、边框、内边距、圆角、鼠标指针。
*   定义不同状态的词块样式：
    *   `.chip.selected`: 右侧被选中的诊疗动作，高亮显示（如：更深的背景色，加粗边框）。
    *   `.chip.linked`: 左侧与当前选中动作已链接的问题，高亮显示（如：与selected同色系的边框）。
*   定义按钮和整体布局的美观样式。

### 5.3. JavaScript逻辑 (`script.js`)

这是前端交互的核心，管理着应用的状态和与后端的通信。

*   **全局状态变量**:
    ```javascript
    let currentPatientId = null;
    let patientIds = [];
    let problemsData = [];
    let solutionsData = [];
    let annotationLinks = {}; // 结构: { solutionId: [problemId1, problemId2], ... }
    let selectedSolutionId = null;
    ```

*   **核心函数**:

    1.  `init()`: 页面加载时执行。
        *   调用后端 `/api/patients` 获取所有患者ID。
        *   加载第一个患者的数据 `loadPatient(patientIds[0])`。

    2.  `loadPatient(patientId)`:
        *   显示加载中的提示。
        *   调用后端 `GET /api/patient/<patientId>`。
        *   成功后，用返回的数据填充全局状态变量。
        *   调用 `renderProblems()` 和 `renderSolutions()` 渲染界面。
        *   更新患者信息标题。

    3.  `renderProblems()`:
        *   清空 `#problems-container`。
        *   遍历 `problemsData`，为每个问题创建一个 `div.chip` 元素。
        *   给每个chip设置 `data-id` 属性（唯一ID）。
        *   绑定 `click` 事件监听器到每个chip上，用于处理链接逻辑。

    4.  `renderSolutions()`:
        *   清空 `#solutions-container`。
        *   遍历 `solutionsData`，为每个诊疗动作创建一个 `div.chip` 元素。
        *   给每个chip设置 `data-id` 属性，并使其 `contentEditable=false`。
        *   绑定 `click` 事件：处理选中/取消选中逻辑。
        *   绑定 `dblclick` 事件：将 `contentEditable` 设为 `true`，让用户可以编辑。当编辑完成（`blur`事件），更新 `solutionsData` 中的文本。

    5.  **事件处理逻辑**:
        *   **点击右侧方案 (Solution Chip)**:
            *   如果点击的是已选中的，则取消选中 (`selectedSolutionId = null`)。
            *   否则，将点击的chip的ID存入 `selectedSolutionId`。
            *   更新所有左右两侧chip的CSS类（`.selected`, `.linked`），以反映当前选择和链接状态。
        *   **点击左侧问题 (Problem Chip)**:
            *   如果没有选中的方案，则无操作。
            *   如果已有选中的方案 (`selectedSolutionId != null`)：
                *   检查该问题是否已与当前方案链接。
                *   如果已链接，则从 `annotationLinks[selectedSolutionId]` 数组中移除该问题ID（取消链接）。
                *   如果未链接，则添加到数组中（建立链接）。
            *   更新该问题chip的CSS类（添加/移除 `.linked`）。

    6.  `saveAnnotations()`:
        *   调用后端 `POST /api/save/<currentPatientId>`，将当前的 `annotationLinks` 和 `solutionsData` (为了保存修改过的文本) 作为JSON体发送。
        *   显示成功或失败的提示。

*   **导航与保存按钮事件绑定**:
    *   `#prev-patient`, `#next-patient`: 根据 `patientIds` 数组找到上一个/下一个ID，调用 `loadPatient()`。
    *   `#save-btn`: 调用 `saveAnnotations()`。

## 6. 用户工作流程

1.  **启动**: 用户在本地终端运行 `python app.py` 启动后端服务器。
2.  **访问**: 用户在浏览器中打开 `http://127.0.0.1:5000`。
3.  **加载**: 页面自动加载第一个患者的数据。`script.js` 调用后端API，后端解析病历，通过LLM标准化诊疗方案，并将所有数据返回。
4.  **标注**:
    *   用户单击右侧的一个诊疗动作（如“解除拥挤”），该词块高亮。
    *   用户在左侧单击相关的“问题”（如“上牙列中度拥挤”、“下牙列轻度拥挤”），这些问题词块也随之高亮。
    *   若想取消某个链接，再次点击左侧高亮的问题词块即可。
    *   若想标注下一个诊疗动作，只需单击右侧另一个动作，界面会自动更新高亮状态。
5.  **编辑**: 用户双击右侧某个诊疗动作，可以直接修改其文本描述。
6.  **保存**: 用户点击“保存标注”按钮。前端将所有链接关系和修改后的动作文本发送到后端。后端保存标注JSON文件，并用新的动作更新全局的动作库 `action_library.json`。
7.  **导航**: 用户点击“下一例”，流程重复。由于动作库已更新，下一个病历的方案标准化会更精准、更倾向于复用已有表述。

---

这份开发文档提供了从架构设计到代码实现层面的完整蓝图。根据这份文档，开发者可以分步实现前后端功能，最终构建出完全符合您设想的、高效智能的标注工具。